Navbar(isAuth, token) > NavbarAuth or NavbarUnauth [login, signup, logout]
Posts(isAuth, token) [fetch, render posts, load form or not] > Post
Replies(isAuth, token) [fetch, render post and replies, load form or not] > reply
Footer [empty]

--------------------------------------------------------------------------------------

render all routes inside switch always
protect your routes:
wrap route
; conditional render redirect, or programmatic redirect via history obj via withrouter
or can pass in props to route instead and have that component handle redirect
; with history obj or redirect
if dont need redirect aka protected routes then just normal conditional render

rerender only via state change, pass prop down and pass state up
state should flow down via props and be provided to all children that needs it
; thus lift state up to provide
; the patterns are: you either lift state up, or divide up and nest more
; all to prevent rerendering/refetching
thus where you keep the state should be where you fetch/store it (comp or localstore)

functional comp, class comp
when? rerender? state change? (lifecycle) mount/update/unmount/usestate/useeffect/hooks

--------------------------------------------------------------------------------------

AuthChecker
    Navbar
        NavAuth || NavUnauth

    Switch
        Route
            Posts
                PostsAuth || PostsUnauth
        Route
            Replies
                RepliesAuth || RepliesUnauth
        ProtectedRoute
            LoginForm
        ProtectedRoute
            SignupForm

    Footer
#

ApiClient